#!/usr/bin/env bun
/**
 * # PAI Command Scaffolder
 *
 * ## Purpose
 * Interactive tool for creating properly structured PAI commands.
 * Generates boilerplate code following PAI patterns and best practices.
 *
 * ## Usage
 * ```bash
 * # Interactive mode - guided command creation
 * bun ${PAI_DIR}/commands/pai-scaffold.md
 * 
 * # Quick mode - specify command name and type
 * bun ${PAI_DIR}/commands/pai-scaffold.md --name my-command --type hybrid
 * 
 * # Available types: instructional, executable, hybrid, shell
 * bun ${PAI_DIR}/commands/pai-scaffold.md --name test --type instructional
 * ```
 *
 * ## Command Types
 * - **instructional**: Pure markdown documentation for AI to follow
 * - **executable**: TypeScript file with .ts extension
 * - **hybrid**: Markdown file with shebang + JSDoc (recommended)
 * - **shell**: Bash script with .sh extension
 */

import { writeFileSync, existsSync, chmodSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';
import * as readline from 'readline';

interface CommandConfig {
  name: string;
  type: 'instructional' | 'executable' | 'hybrid' | 'shell';
  description: string;
  purpose: string;
  usage: string;
  directory: string;
  author: string;
}

function createReadlineInterface() {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });
}

async function prompt(question: string, rl: readline.Interface): Promise<string> {
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      resolve(answer.trim());
    });
  });
}

async function interactiveMode(): Promise<CommandConfig> {
  const rl = createReadlineInterface();
  
  console.log('\nüöÄ PAI Command Scaffolder - Interactive Mode');
  console.log('='.repeat(50));
  
  const config: Partial<CommandConfig> = {};
  
  // Get command name
  config.name = await prompt('\nüìù Command name (without extension): ', rl);
  if (!config.name) {
    console.error('‚ùå Command name is required');
    process.exit(1);
  }
  
  // Get command type
  console.log('\nüìã Available command types:');
  console.log('  1. instructional - Pure markdown for AI to follow');
  console.log('  2. hybrid - Executable markdown with TypeScript (recommended)');
  console.log('  3. executable - Pure TypeScript file');
  console.log('  4. shell - Bash script');
  
  const typeChoice = await prompt('\nSelect type (1-4) or type name: ', rl);
  const typeMap = {
    '1': 'instructional',
    '2': 'hybrid', 
    '3': 'executable',
    '4': 'shell'
  };
  
  config.type = typeMap[typeChoice] || typeChoice as any;
  if (!['instructional', 'hybrid', 'executable', 'shell'].includes(config.type!)) {
    console.error('‚ùå Invalid command type');
    process.exit(1);
  }
  
  // Get description and purpose
  config.description = await prompt('\nüìñ Brief description: ', rl);
  config.purpose = await prompt('üéØ Detailed purpose: ', rl);
  config.usage = await prompt('üí° Usage example: ', rl);
  
  // Get directory
  const paiDir = process.env.PAI_DIR || join(homedir(), '.claude');
  const defaultDir = join(paiDir, 'commands');
  const dirChoice = await prompt(`\nüìÅ Directory [${defaultDir}]: `, rl);
  config.directory = dirChoice || defaultDir;
  
  // Get author
  const defaultAuthor = process.env.USER || 'PAI User';
  const authorChoice = await prompt(`\nüë§ Author [${defaultAuthor}]: `, rl);
  config.author = authorChoice || defaultAuthor;
  
  rl.close();
  
  return config as CommandConfig;
}

function generateInstructionalCommand(config: CommandConfig): string {
  return `# ${config.name}

## Purpose
${config.purpose}

## Description
${config.description}

## Usage
\`\`\`bash
${config.usage || `# Example usage of ${config.name}`}
\`\`\`

## Instructions
1. [Add your step-by-step instructions here]
2. [The AI will read and execute these instructions]
3. [Use clear, actionable language]

## Examples
\`\`\`bash
# Add example commands here
echo "Example command"
\`\`\`

## Notes
- Add any important notes or considerations
- Include prerequisites or dependencies
- Document expected outputs

---
*Generated by PAI Scaffolder on ${new Date().toISOString()}*
*Author: ${config.author}*
`;
}

function generateHybridCommand(config: CommandConfig): string {
  return `#!/usr/bin/env bun
/**
 * # ${config.name}
 *
 * ## Purpose
 * ${config.purpose}
 *
 * ## Description
 * ${config.description}
 *
 * ## Usage
 * \`\`\`bash
 * ${config.usage || `bun \${PAI_DIR}/commands/${config.name}.md`}
 * \`\`\`
 *
 * ## Examples
 * \`\`\`bash
 * # Basic usage
 * bun \${PAI_DIR}/commands/${config.name}.md
 * 
 * # With arguments
 * bun \${PAI_DIR}/commands/${config.name}.md --option value
 * \`\`\`
 *
 * @author ${config.author}
 * @created ${new Date().toISOString()}
 */

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

interface ${toPascalCase(config.name)}Options {
  // Define your options interface here
  verbose?: boolean;
  output?: string;
}

function main() {
  const args = process.argv.slice(2);
  
  // Parse command line arguments
  const options: ${toPascalCase(config.name)}Options = {
    verbose: args.includes('--verbose') || args.includes('-v'),
    output: args.find(arg => arg.startsWith('--output='))?.split('=')[1]
  };
  
  console.log('üöÄ Starting ${config.name}...');
  
  try {
    // Add your main logic here
    console.log('‚úÖ ${config.name} completed successfully');
  } catch (error) {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
  }
}

function toPascalCase(str: string): string {
  return str.replace(/(^|-)([a-z])/g, (_, __, letter) => letter.toUpperCase());
}

// Run the command
main();
`;
}

function generateExecutableCommand(config: CommandConfig): string {
  return `#!/usr/bin/env bun

/**
 * ${config.name} - ${config.description}
 * 
 * Purpose: ${config.purpose}
 * Author: ${config.author}
 * Created: ${new Date().toISOString()}
 */

import { readFileSync, writeFileSync } from 'fs';
import { join } from 'path';

interface Options {
  verbose?: boolean;
  help?: boolean;
}

function parseArgs(): Options {
  const args = process.argv.slice(2);
  return {
    verbose: args.includes('--verbose') || args.includes('-v'),
    help: args.includes('--help') || args.includes('-h')
  };
}

function showHelp() {
  console.log(\`
Usage: bun ${config.name}.ts [options]

${config.description}

Options:
  -v, --verbose    Enable verbose output
  -h, --help       Show this help message

Examples:
  ${config.usage || `bun ${config.name}.ts`}
\`);
}

function main() {
  const options = parseArgs();
  
  if (options.help) {
    showHelp();
    return;
  }
  
  console.log('üöÄ Starting ${config.name}...');
  
  try {
    // Add your main logic here
    
    if (options.verbose) {
      console.log('‚ÑπÔ∏è Verbose mode enabled');
    }
    
    console.log('‚úÖ ${config.name} completed successfully');
  } catch (error) {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
  }
}

main();
`;
}

function generateShellCommand(config: CommandConfig): string {
  return `#!/bin/bash

# ${config.name} - ${config.description}
# Purpose: ${config.purpose}
# Author: ${config.author}
# Created: ${new Date().toISOString()}

set -euo pipefail

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
NC='\\033[0m' # No Color

# Default options
VERBOSE=false
HELP=false

# Function to show help
show_help() {
    cat << EOF
Usage: ${config.name}.sh [options]

${config.description}

Options:
    -v, --verbose    Enable verbose output
    -h, --help       Show this help message

Examples:
    ${config.usage || `./${config.name}.sh`}

EOF
}

# Function for logging
log() {
    echo -e "\${GREEN}[INFO]\${NC} $1"
}

log_error() {
    echo -e "\${RED}[ERROR]\${NC} $1" >&2
}

log_warning() {
    echo -e "\${YELLOW}[WARNING]\${NC} $1"
}

log_verbose() {
    if [ "$VERBOSE" = true ]; then
        echo -e "\${BLUE}[VERBOSE]\${NC} $1"
    fi
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            HELP=true
            shift
            ;;
        *)
            log_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Show help if requested
if [ "$HELP" = true ]; then
    show_help
    exit 0
fi

# Main function
main() {
    log "Starting ${config.name}..."
    
    log_verbose "Verbose mode enabled"
    
    # Add your main logic here
    
    log "${config.name} completed successfully"
}

# Run main function
main "$@"
`;
}

function toPascalCase(str: string): string {
  return str.replace(/(^|-)([a-z])/g, (_, __, letter) => letter.toUpperCase());
}

function createCommand(config: CommandConfig) {
  let content: string;
  let extension: string;
  
  switch (config.type) {
    case 'instructional':
      content = generateInstructionalCommand(config);
      extension = '.md';
      break;
    case 'hybrid':
      content = generateHybridCommand(config);
      extension = '.md';
      break;
    case 'executable':
      content = generateExecutableCommand(config);
      extension = '.ts';
      break;
    case 'shell':
      content = generateShellCommand(config);
      extension = '.sh';
      break;
    default:
      throw new Error(`Unknown command type: ${config.type}`);
  }
  
  const filename = `${config.name}${extension}`;
  const filepath = join(config.directory, filename);
  
  // Check if file already exists
  if (existsSync(filepath)) {
    console.error(`‚ùå File already exists: ${filepath}`);
    process.exit(1);
  }
  
  // Create the file
  writeFileSync(filepath, content);
  
  // Make executable if needed
  if (config.type !== 'instructional') {
    chmodSync(filepath, 0o755);
  }
  
  console.log(`\n‚úÖ Command created successfully!`);
  console.log(`üìÅ Location: ${filepath}`);
  console.log(`üìã Type: ${config.type}`);
  console.log(`üîß Executable: ${config.type !== 'instructional' ? 'Yes' : 'No'}`);
  
  if (config.type !== 'instructional') {
    console.log(`\nüöÄ Test your command:`);
    console.log(`   bun ${filepath}`);
  }
  
  console.log(`\nüí° Next steps:`);
  console.log(`   1. Edit the file to add your specific logic`);
  console.log(`   2. Test the command thoroughly`);
  console.log(`   3. Add it to your PAI workflow`);
}

async function main() {
  const args = process.argv.slice(2);
  
  // Check for quick mode arguments
  const nameArg = args.find(arg => arg.startsWith('--name='))?.split('=')[1];
  const typeArg = args.find(arg => arg.startsWith('--type='))?.split('=')[1];
  
  let config: CommandConfig;
  
  if (nameArg && typeArg) {
    // Quick mode
    const paiDir = process.env.PAI_DIR || join(homedir(), '.claude');
    config = {
      name: nameArg,
      type: typeArg as any,
      description: `${nameArg} command`,
      purpose: `Purpose of ${nameArg} command`,
      usage: `bun \${PAI_DIR}/commands/${nameArg}.md`,
      directory: join(paiDir, 'commands'),
      author: process.env.USER || 'PAI User'
    };
    
    if (!['instructional', 'hybrid', 'executable', 'shell'].includes(config.type)) {
      console.error('‚ùå Invalid type. Use: instructional, hybrid, executable, or shell');
      process.exit(1);
    }
  } else {
    // Interactive mode
    config = await interactiveMode();
  }
  
  createCommand(config);
}

main().catch(error => {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
});
